.\" Written by Sébastien Millet
.\"
.TH pRPN 1 "version 0.6.0" "October 10h, 2020"

.SH NAME
pRPN \- a portable RPN calculator

.SH SYNOPSIS
.B prpn [options]
.br
.B prpnc [options]
.TP
prpn is the main, GUI, executable. prpnc is the command line version. \fBprpnc\fP is equivalent to \fBprpn -c\fP.
.br

.SH DESCRIPTION
The \fBpRPN\fP program is a RPN calculator inspired by HP calculators of late 80s.
.SH OPTIONS
.TP
.B \-h,\ \-\-help
Display a quick help screen and exit.
.TP
.B \-v\ \-\-version
Display version information and exit.
.TP
.B \-c,\ \-\-console
Run in console mode. Useful for prpn only. prpnc runs only in console mode.
.TP
.B \-w,\ \-\-width\ \fIwidth\fP
Set width to \fIwidth\fP, measured in number of characters. Defaults to 23.
.TP
.B \-h,\ \-\-height\ \fIheight\fP
Set height to \fIheight\fP, measured in number of lines. Defaults to 5.
.TP
.B \-\-min-stack-height\ \fImin-stack-height\fP
Set minimum stack height to \fIheight\fP, measured in number of lines. Defaults to \fIheight\fP. Only in console mode.
.TP
.B \-b,\ \-\-batch
Batch mode, implies console mode.
.TP
.B \-z,\ \-\-dry\-run
Ignore rc files.
.TP
.B \-a,\ \-\-class
Display class count before exiting.
.TP
.B \-d,\ \-\-debug\ \fIdebug_option\fP
Debug mode, requires a parameter.
.SH "OBJECT TYPES"
.TP
.I Data
.TP
.B Real Number
1.23456e-25    
.TP
.B Complex Number
( )	(123.45, 678.90)
.TP
.B Binary Integer
#	# 123AB
.TP
.B String
" "	"RESULT"
.TP
.B Vector
[ ]	[1.23 4.56 7.89]
.TP
.B Matrix
[[ ]]	[[1.23 4.56] [6.54 3.21]]
.TP
.B List
{ }	{1.23 "ABC" # 45d}
.TP
.I Names
.TP
.B Name
\' \'	\'CALC\'
.TP
.I Procedures
.TP
.B Program
<< >>	<< DUP + SWAP >>
.TP
.B Algebraic
\' \'	\'X+2*Y=Z\'
.SH COMMANDS
Commands are followed by the number of arguments they take, in parenthesis. These arguments are taken from the stack.
.TP
.B _HELP\ (0)
Display a help screen
.TP
.B _HELP_FLAGS\ (0)
Display the list of flags
.TP
.B _EXIT\ (0)
Quit program
.TP
.B _ABOUT\ (0)
Display information about this program
.TP
.B +\ (2)
Addition: x + y
.TP
.B -\ (2)
Subtraction: x - y
.TP
.B *\ (2)
Multiplication: x * y
.TP
.B /\ (2)
Division: x / y
.TP
.B ^\ (2)
Power: x ^ y
.TP
.B %\ (2)
Percentage: (x * y) / 100
.TP
.B %CH\ (2)
Percentage change: 100 * (y - x) / x
.TP
.B %T\ (2)
Percentage of total: 100 * y / x
.TP
.B MOD\ (2)
Modulus: x - y * FLOOR(x / y)
.TP
.B MIN\ (2)
Minimum of two reals
.TP
.B MAX\ (2)
Maximum of two reals
.TP
.B COS\ (1)
Cosine
.TP
.B SIN\ (1)
Sine
.TP
.B TAN\ (1)
Tangent
.TP
.B ACOS\ (1)
Arccos
.TP
.B ASIN\ (1)
Arcsin
.TP
.B ATAN\ (1)
Arctan
.TP
.B LN\ (1)
Logarihtm (e base)
.TP
.B EXP\ (1)
Exponential
.TP
.B LOG\ (1)
Logarithm (10 base)
.TP
.B ALOG\ (1)
10 base exponential (10^x)
.TP
.B LNP1\ (1)
LN(1+x)
.TP
.B EXPM\ (1)
EXP(x)-1
.TP
.B COSH\ (1)
Hyperbolic cosine
.TP
.B SINH\ (1)
Hyperbolic sine
.TP
.B TANH\ (1)
Hyperbolic tangent
.TP
.B ACOSH\ (1)
Arc-hyperbolic cosine
.TP
.B ASINH\ (1)
Arc-hyperbolic sine
.TP
.B ATANH\ (1)
Arc-hyperbolic tangent
.TP
.B NEG\ (1)
Opposite
.TP
.B IP\ (1)
Integer part
.TP
.B FP\ (1)
Fractional part
.TP
.B FLOOR\ (1)
Greatest integer lower than or equal to x
.TP
.B CEIL\ (1)
Lowest integer greater than or equal to x
.TP
.B ABS\ (1)
Absolute of x
.TP
.B SIGN\ (1)
Sign of x: can be -1, 0 or 1
.TP
.B MANT\ (1)
Mantisse of x
.TP
.B XPON\ (1)
Exponent of x
.TP
.B INV\ (1)
1/x
.TP
.B SQ\ (1)
Square
.TP
.B SQR\ (1)
Square root
.TP
.B RDZ\ (1)
Initializes random values series, 0 to start from a timer value
.TP
.B RAND\ (0)
Get a random value x, 0 <= x < 1
.TP
.B MINR\ (0)
Smallest real greater than zero the calcultor can represent
.TP
.B MAXR\ (0)
Biggest real the calcultor can represent
.TP
.B ->HMS\ (1)
Convert a decimal to HMS (h.MMSSss)
.TP
.B HMS->\ (1)
Convert a HMS (h.MMSSss) to a decimal
.TP
.B HMS+\ (2)
Add two HMS (h.MMSSss)
.TP
.B HMS-\ (2)
Subtract two HMS (h.MMSSss)
.TP
.B D->R\ (1)
Convert from degrees to radians
.TP
.B R->D\ (1)
Convert from radians to degrees
.TP
.B RAD\ (0)
Set angular mode to radians
.TP
.B DEG\ (0)
Set angular mode to degrees
.TP
.B +ML\ (0)
Display first item on multilpe lines
.TP
.B -ML\ (0)
Display first item on a single line
.TP
.B RDXP\ (0)
Set the decimal separator to '.'
.TP
.B RDXC\ (0)
Set the decimal separator to ','
.TP
.B R->C\ (2)
Real to complex
.TP
.B C->R\ (1)
Complex to real
.TP
.B RE\ (1)
Get real part of a complex number or array
.TP
.B IM\ (1)
Get imaginary part of a complex number or array
.TP
.B CONJ\ (1)
Get conjugate of a complex number or array
.TP
.B ARG\ (1)
Get argument of a complex number
.TP
.B R->P\ (1)
Rectangular to polar coordinates
.TP
.B P->R\ (1)
Polar to rectangular coordinates
.TP
.B SAME\ (2)
Is identical
.TP
.B ==\ (2)
Equal to
.TP
.B <>\ (2)
Different from
.TP
.B <\ (2)
Lower than
.TP
.B <=\ (2)
Lower than or equal to
.TP
.B >\ (2)
Greater than
.TP
.B >=\ (2)
Greater than or equal to
.TP
.B AND\ (2)
Logical and
.TP
.B OR\ (2)
Logical or
.TP
.B XOR\ (2)
Logical xor
.TP
.B NOT\ (1)
Logical not
.TP
.B DUP\ (1)
Copy the first item
.TP
.B SWAP\ (2)
Exchange the first two items
.TP
.B DROP\ (1)
Delete the first item
.TP
.B CLEAR\ (0)
Clear the stack
.TP
.B OVER\ (2)
Copy the second item
.TP
.B DUP2\ (2)
Copy the first two items
.TP
.B DROP2\ (2)
Delete the first two items
.TP
.B ROT\ (3)
Move the third item to the first position
.TP
.B ROLLD\ (1)
Move the first item to the Nth position
.TP
.B ROLL\ (1)
Move the Nth item to the first position
.TP
.B PICK\ (1)
Copy the Nth item
.TP
.B DUPN\ (1)
Copy the n first items
.TP
.B DROPN\ (1)
Delete the n first items
.TP
.B DEPTH\ (0)
Get the number of items
.TP
.B SF\ (1)
Set flag
.TP
.B CF\ (1)
Clear flag
.TP
.B FS?\ (1)
Return 1 if flag is set, 0 otherwise
.TP
.B FC?\ (1)
Return 0 if flag is set, 1 otherwise
.TP
.B FS?C\ (1)
Do FS? then clear flag
.TP
.B FC?C\ (1)
Do FC? then clear flag
.TP
.B ->STR\ (1)
Convert to string
.TP
.B STR->\ (0)
Convert from string
.TP
.B SUB\ (3)
Extract content from a string or a list
.TP
.B ->LIST\ (1)
Items to list
.TP
.B LIST->\ (1)
Extract items from list
.TP
.B GET\ (2)
Get an item from a list or array
.TP
.B GETI\ (2)
Get an item from a list or array by increments
.TP
.B PUT\ (3)
Put an item into a list or array
.TP
.B PUTI\ (3)
Put an item into a list or array by increments
.TP
.B SIZE\ (1)
Dimension of a list or array
.TP
.B ARRY->\ (1)
Replace an array by all its elements
.TP
.B ->ARRY\ (1)
Create an array from a list of elements
.TP
.B CON\ (2)
Create a constant array
.TP
.B TRN\ (1)
Transpose a matrix-type array
.TP
.B RDM\ (2)
Modify the dimension of an array
.TP
.B IDN\ (1)
Create an identity matrix
.TP
.B CROSS\ (2)
Cross product (vectorial product)
.TP
.B DOT\ (2)
Dot product (scalar product)
.TP
.B EVAL\ (0)
Evaluate item
.TP
.B STO\ (2)
Store value in variable name
.TP
.B RCL\ (1)
Recall value from variable name
.TP
.B PURGE\ (1)
Remove a variable
.TP
.B VARS\ (0)
Get the list of variables in current directory
.TP
.B PATH\ (0)
Get the list from root to current directory
.TP
.B CRDIR\ (1)
Create a directory
.TP
.B HOME\ (0)
Set root directory as the current one
.TP
.B UP\ (0)
Make the parent directory the current one
.TP
.B BIN\ (0)
Use binary mode for binary integers
.TP
.B OCT\ (0)
Use octal mode for binary integers
.TP
.B DEC\ (0)
Use decimal mode for binary integers
.TP
.B HEX\ (0)
Use hexadecimal mode for binary integers
.TP
.B STWS\ (1)
Define the number of bits in binary integers (1 to 64)
.TP
.B RCWS\ (0)
Get the number of bits in binary integers
.TP
.B B->R\ (1)
Convert a binary integer into a real
.TP
.B R->B\ (1)
Convert a real into a binary integer
.TP
.B RCLF\ (0)
Save flag states in a binary integer
.TP
.B STOF\ (1)
Read flag states from a binary integer
.TP
.B WAIT\ (1)
Wait a number of seconds
.TP
.B HALT\ (0)
Halt program execution
.TP
.B SST\ (0)
Execute one step in the program
.TP
.B ABORT\ (0)
Abort current program execution
.TP
.B KILL\ (0)
Abort all programs execution
.TP
.B CONT\ (0)
Resume program execution
.TP
.B STD\ (0)
Set reals display to 'standard'
.TP
.B SCI\ (1)
Set reals display to 'scientific'
.TP
.B FIX\ (1)
Set reals display to 'fixed number of decimals'
.TP
.B ENG\ (1)
Set reals display to 'engineering'
.TP
.B CLLCD\ (0)
Clear the screen
.TP
.B CLMF\ (0)
Clear the message flag => unfreeze stack display
.TP
.B DISP\ (2)
Display an item on a line of the screen
.TP
.B _READ\ (1)
Read file and puts its content in the stack
.TP
.B _WRITE\ (2)
Write the second item into the file named by the first item
.TP
.B _HACK-REAL-MGMT\ (1)
Internal: tune real 'standard' display management
.TP
.B _HACK-REAL-DOT\ (1)
Internal: set whether or not to keep a trailing dot in reals display
.TP
.B UNDO\ (0)
Undo last command, 50 levels by default
.TP
.B _UNDO_LEVELS\ (1)
Define number of undo levels
.TP
.B _UNDO_LEVELS?\ (0)
Get number of undo levels
.TP
.B _UISET\ (1)
Define the type of user interface
.SH "LINEAR EQUATIONS SYSTEMS RESOLUTION"
.TP
You can solve a linear system by dividing a vector by a matrix.
.br
.I Example
You would like to resolve the system
.br
  2x - y + z = 13
  x + 5y +3z = 3
  -2x + 4z = 4
.br
Type in the vector
.br
  [13 3 4]
.br
Then type in the matrix
.br
  [[2 -1 1][1 5 3][-2 0 4]]
.br
Do a division by clicking the '/' button. Here you go with
the result:
.br
  [4 -2 3]
.br
That reads "the solution is x = 4, y = -2 and z = 3"
.SH "PROGRAM CONTROL INSTRUCTIONS"
.TP
.B Note about booleans
A test (IF, WHILE or UNTIL, see below) takes one item in the stack. The item
must be of type real. Any non-null value is treated as TRUE, a null value is
FALSE.
.br
Below, the term "bottom item of the stack" refers to the actual object at
level 1 of the stack.
.TP
.B IF/THEN/ELSE/END sequence
Execute the instructions between IF and THEN.
.br
Then, take the bottom item of the stack, if it is true (see above), execute
the instructions between THEN and ELSE (or END if ELSE is not provided),
otherwise execute the ELSE instructions. ELSE is optional.
.TP
.I Example 1
Take the first item in the stack and tell whether it is positive or null, or
negative
.br
<< IF 0 >= THEN "Positive or null" ELSE "Negative" END >>
.TP
.I Example 2
Always execute the THEN part
.br
<< IF 1 THEN "Always executed" ELSE "Never executed" END >>
.TP
.I Example 3
Do nothing (!)
.br
<< IF 0 THEN "Never executed" END >>
.TP
.B WHILE/REPEAT/END sequence
Execute the instructions between WHILE and REPEAT.
.br
Then take the bottom item of the stack, if it is true (see above), execute the
instructions after REPEAT, then restart the sequence from the beginning of the
WHILE.
.TP
.I Example
Calculate the smallest N for which sum(i^2 with i taking all integer values in
the range 1..N) >= 100
.br
<< 0 0 -> n << WHILE DUP 100 < REPEAT n SQ + n 1 + 'n' STO END n >> >>
.TP
.B DO/UNTIL/END sequence
Execute the instructions between DO and UNTIL, then, between UNTIL and END.
.br
Then, take the bottom item of the stack, if it is true (see above), restart
the sequence from the beginning of the DO.
.TP
.I Example
Calculate the smallest N for which sum(1/i with i taking all integer values in the range 1..N) >= 3
.br
<< 0 0 -> n << DO n 1 + 'n' STO n INV + UNTIL DUP 7 >= END n >> >>
.TP
.B FOR|START/NEXT|STEP sequence
FOR or START launches a loop. It takes two arguments, the first argument
(second level in the stack) being the start counter value, the second one
(first level in the stack) being the target counter value, beyond which to
stop the loop.
.br
START is an anonymous loop, FOR takes one name and uses it as a local variable
for the loop counter.
.br
NEXT adds 1 to the counter if the target is greater than the start, subtracts
1 otherwise.
.br
STEP takes one argument in the stack and adds it to the counter. NEXT can be
used with either FOR or START, same with STEP.
.TP
.I Example 1
Calculate the sum of the squares of the integers from 1 to 10
.br
<< 0 1 10 FOR i i SQ + NEXT >>
.TP
.I Example 2
Calculate sum(2^i with i taking all integer values in the range 1..N), N being
the first value in the stack
.br
<< 0 1 1 4 ROLL START DUP ROT + SWAP 2 * NEXT DROP >> EVAL
.TP
.I Example 3
Calculate sum(i with i taking all odd integer values in the range 1..N), N
being the first value in the stack
.br
<< 0 1 ROT FOR i i + 2 STEP >>
.TP
.B RPL Documentation
RPL is HP language provided on top of RPN calculators.
.br
http://en.wikipedia.org/wiki/RPL_%28programming_language%29
.SH "TRICKS"
.TP
.B Increasing the type-in area
.br
Press <Ctrl-Enter>.
.br
.br
.TP
.B Resizing the window to the original size
.br
Double-click the 'status' area of the window, where the angular mode and binary modes are displayed.
.SH "INITIALIZATION FILES"
.TP
.B ~/.prpn/stackrc
Settings and stack content.
.TP
.B ~/.prpn/varsrc
Variables structure, and actual working directory.
.SH AUTHOR
Written by Sébastien Millet <sebastien.millet1@club-internet.fr>.
.br
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU General Public License, Version 3 published by the Free Software Foundation.
.SH BUGS
.B LNP1 and EXPM
.TP
These functions are supposed to bring extra accuracy near x = 0. Reminder:
LNP1(x) = LN(X + 1) and EXPM(x) = EXP(x) - 1
.br
For now, these functions do NOT bring extra accuracy, they just call underlying LN() and EXP() functions.
.br
.br
.TP
.B Difference between prpn and prpnc
.TP
.I Linux
prpn can be run with -c option. In that case it is almost identical to prpnc. "Almost" only. prpn is compiled with WxWidgets library and performs GUI-specific initializations upon startup. If graphical resources aren't found, it won't execute. For example, if you run the following command
.br
\fB	DISPLAY="" prpn -c\fP
.br
You get this result
.br
\fB	Error: Unable to initialize gtk, is DISPLAY set properly?\fP
.br
prpnc solves this situation, as it is *not* compiled against WxWidgets and can run in a simple terminal with no graphical resources at all. Note a clean way to improve all this would be to prevent WxWidgets from initializing the GUI whenever -c is provided. If you know how to do that in a robust way (portable across systems and versions...), this program' author is interested!
.TP
.I Windows
prpn.exe can *not* be run with -c. For some reason, under Windows, WxWidgets disconnects the running program from the controlling terminal. The solutions is the same as Linux' except that under Windows, it is mandatory: you must run prpnc.exe if you wish to use the command line version of the calculator.
