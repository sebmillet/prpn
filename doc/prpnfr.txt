pRPN(1) 							       pRPN(1)



NAME
       pRPN  -	une  calculatrice en notation polonaise inverse multi systèmes
       d'exploitation


SYNOPSIS
       prpn [options]
       prpnc [options]

       prpn est l'exécutable principal, en mode graphique. prpnc est  la  ver‐
       sion en ligne de commande. prpnc est équivalent à prpn -c.


DESCRIPTION
       Le  programme  pRPN  est une calculatrice en notation polonaise inverse
       inspirée des calculatrices HP de la fin des années 80.

OPTIONS
       -h, --help
	      Affiche l'aide et quitte.

       -v --version
	      Affiche le numéro de version et quitte.

       -c, --console
	      Exécution en mode console.

       -w, --width width
	      Définis la largeur à width, mesurée en nombre de caractères.  23
	      par défaut.

       -h, --height height
	      Définis  la hauteur à height, mesurée en nombre de lignes. 5 par
	      défaut.

       --min-stack-height min-stack-height
	      Définis la hauteur minimale  à  height,  mesurée	en  nombre  de
	      lignes. height par défaut. Uniquement en mode console.

       -b, --batch
	      Mode batch, implique le mode console.

       -z, --dry-run
	      Ignore les fichiers rc.

       -a, --class
	      Affiche le comptage des classes avant de terminer.

       -d, --debug debug_option
	      Mode debug, prend un paramètre.

TYPES D'OBJETS
       Donnée

       Nombre réel
	      1.23456e-25

       Nombre complexe
	      ( )  (123.45, 678.90)

       Entier binaire
	      #    # 123AB

       Chaîne de caractères
	      " "  "RESULT"

       Vecteur
	      [ ]  [1.23 4.56 7.89]

       Matrice
	      [[ ]]	[[1.23 4.56] [6.54 3.21]]

       Liste  { }  {1.23 "ABC" # 45d}

       Noms

       Nom    ´ ´  ´CALC´

       Procédures

       Programme
	      << >>	<< DUP + SWAP >>

       Algébrique
	      ´ ´  ´X+2*Y=Z´

COMMANDES
       Les  commandes  sont  suivies  du nombre d'arguments qu'elles prennent,
       entre parenthèses. Ces arguments sont pris dans la pile.

       _HELP (0)
	      Affiche un écran d'aide

       _HELP_FLAGS (0)
	      Affiche un écran d'aide sur les options

       _EXIT (0)
	      Quitte le programme

       _ABOUT (0)
	      Affiche des informations au sujet de ce programme

       + (2)  Addition : x + y

       - (2)  Soustraction : x - y

       * (2)  Multiplication : x * y

       / (2)  Division : x / y

       ^ (2)  Puissance : x ^ y

       % (2)  Pourcentage : (x * y) / 100

       %CH (2)
	      Pourcentage de changement : 100 * (y - x) / x

       %T (2) Pourcentage du total : 100 * y / x

       MOD (2)
	      Modulo : x - y * FLOOR(x / y)

       MIN (2)
	      Minimum

       MAX (2)
	      Maximum

       COS (1)
	      Cosinus

       SIN (1)
	      Sinus

       TAN (1)
	      Tangente

       ACOS (1)
	      Arc-cosinus

       ASIN (1)
	      Arc-sinus

       ATAN (1)
	      Arc-tangente

       LN (1) Logarithme (base e)

       EXP (1)
	      Exponentiel

       NEG (1)
	      Opposé

       IP (1) Partie entière

       FP (1) Partie décimale

       FLOOR (1)
	      Plus grand entier inférieur ou égal à x

       CEIL (1)
	      Plus petit entier supérieur ou égal à x

       ABS (1)
	      Valeur absolue

       SIGN (1)
	      Signe de x : peut être -1, 0 ou 1

       MANT (1)
	      Mantisse de x

       XPON (1)
	      Exponentielle de x

       INV (1)
	      1/x

       SQ (1) Carré

       SQR (1)
	      Racine carrée

       R->C (2)
	      Réel à complexe

       C->R (1)
	      Complexe à réel

       SAME (2)
	      Est identique

       == (2) Est égal à

       <> (2) Est différent de

       < (2)  Est plus petit que

       <= (2) Est plus petit que, ou égal à

       > (2)  Est plus grand que

       >= (2) Est plus grand que, ou égal à

       DUP (1)
	      Copie le premier élément

       SWAP (2)
	      Échange les deux premiers éléments

       DROP (1)
	      Supprime le premier élément

       CLEAR (0)
	      Efface la pile

       OVER (2)
	      Copie le second élément

       DUP2 (2)
	      Copie les deux premiers éléments

       DROP2 (2)
	      Supprime les deux premiers éléments

       ROT (3)
	      Déplace le troisième élément en première position

       ROLLD (1)
	      Déplace le premier élément en Nième position

       ROLL (1)
	      Déplace le Ne élément en première position

       PICK (1)
	      Copie le Ne élément

       DUPN (1)
	      Copie les N premiers éléments

       DROPN (1)
	      Supprime les N premiers éléments

       DEPTH (0)
	      Renvoie le nombre d'éléments dans la pile

       SF (1) Active l'option

       CF (1) Désactive l'option

       FS? (1)
	      Renvoie 1 si l'option est activée, 0 sinon

       FC? (1)
	      Renvoie 0 si l'option est activée, 1 sinon

       FS?C (1)
	      Exécute FS? et désactive l'option

       FC?C (1)
	      Exécute FC? et désactive l'option

       ->STR (1)
	      Convertis un élément en chaîne de caractères

       STR-> (0)
	      Convertis une chaîne de caractère en éléments

       SUB (3)
	      Extrais le contenu d'une chaîne de caractères ou d'une liste

       ->LIST (1)
	      Mets les éléments dans une liste

       LIST-> (1)
	      Convertis la liste en ses éléments

       GET (2)
	      Extrais un élément d'une liste ou d'un tableau

       GETI (2)
	      Extrais un élément d'une liste ou d'un tableau par incréments

       PUT (3)
	      Remplace un élément dans une liste ou un tableau

       PUTI (3)
	      Remplace un élément dans une liste ou un tableau par incréments

       SIZE (1)
	      Dimension d'une liste ou d'un tableau

       ARRY-> (1)
	      Remplace un tableau par ses éléments

       ->ARRY (1)
	      Crée un tableau avec les éléments de la pile

       CON (2)
	      Crée un tableau constant

       TRN (1)
	      Transpose une matrice

       RDM (2)
	      Modifie les dimensions d'un tableau

       IDN (1)
	      Crée une matrice identité

       EVAL (0)
	      Évalue l'élément

       STO (2)
	      Enregistre la valeur dans la variable

       RCL (1)
	      Récupère la valeur de la variable

       PURGE (1)
	      Supprime la variable

       VARS (0)
	      Renvoie la liste des variables dans le répertoire courant

       PATH (0)
	      Renvoie le répertoire en cours sous forme de liste

       CRDIR (1)
	      Crée un répertoire

       HOME (0)
	      Définis le répertoire racine comme répertoire courant

       UP (0) Définis le répertoire parent comme répertoire courant

       BIN (0)
	      Utilise le mode binaire pour les entiers binaires

       OCT (0)
	      Utilise le mode octal pour les entiers binaires

       DEC (0)
	      Utilise le mode décimal pour les entiers binaires

       HEX (0)
	      Utilise le mode hexadécimal pour les entiers binaires

       STWS (1)
	      Définis le nombre de bits des entiers binaires (de 1 à 64)

       RCWS (0)
	      Renvoie le nombre de bits des entiers binaires

       B->R (1)
	      Convertis un entier binaire en réel

       R->B (1)
	      Convertis un réel en entier binaire

       RCLF (0)
	      Enregistre l'état des options dans un entier binaire

       STOF (1)
	      Récupère l'état des options depuis un entier binaire

       WAIT (1)
	      Pause d'une durée définie en secondes

       HALT (0)
	      Suspends l'exécution du programme

       SST (0)
	      Exécute une instruction dans le programme

       ABORT (0)
	      Arrête l'exécution du programme courant

       KILL (0)
	      Arrête l'exécution de tous les programmes

       CONT (0)
	      Reprends l'exécution du programme

       STD (0)
	      Règle l'affichage des réels à 'standard'

       SCI (1)
	      Règle l'affichage des réels à 'scientifique'

       FIX (1)
	      Règle l'affichage des réels à 'nombre de décimales fixe'

       ENG (1)
	      Règle l'affichage des réels à 'ingénieur'

       CLLCD (0)
	      Efface l'écran

       CLMF (0)
	      Désarme l'indicateur d'affichage =>  dégèle  l'affichage	de  la
	      pile

       DISP (2)
	      Affiche une chaîne de caractères sur une ligne de l'écran

       _READ (1)
	      Lis le fichier et met son contenu dans la pile

       _WRITE (2)
	      Écris  le second élément de la pile dans le fichier nommé par le
	      premier élément

       _HACK-REAL-MGMT (1)
	      Interne : règle la gestion de  l'affichage  des  réels  en  mode
	      'standard'

       _HACK-REAL-DOT (1)
	      Interne  :  détermine  s'il  faut afficher un point à la fin des
	      réels

       UNDO (0)
	      Annule la dernière commande, 50 niveaux par défaut

       _UNDO_LEVELS (1)
	      Définis le nombre de niveaux d'annulation

       _UNDO_LEVELS? (0)
	      Renvoie le nombre de niveaux d'annulations

RÉSOLUTION DE SYSTÈMES D'ÉQUATIONS LINÉAIRES
       Vous pouvez résoudre un système d'équations linéaires  en  divisant  un
       vecteur par une matrice.
	      Exemple Vous voudriez résoudre le système
		2x - y + z = 13
		x + 5y +3z = 3
		-2x + 4z = 4
	      Saisissez le vecteur
		[13 3 4]
	      Ensuite saisissez la matrice
		[[2 -1 1][1 5 3][-2 0 4]]
	      Faites  une  division en cliquant sur le bouton '/'. Le résultat
	      est là :
		[4 -2 3]
	      Ce qui se lit "la solution est x = 4, y = -2 et z = 3"

INSTRUCTIONS DE CONTRÔLE DES PROGRAMMES
       Note au sujet des booléens
	      Un test (IF, WHILE ou UNTIL, cf. ci-après) prend une valeur dans
	      la  pile.  Cette valeur doit être de type réel. Toute valeur non
	      nulle est traitée comme VRAI, une valeur nulle comme FAUX.
	      Ci-dessous, le terme "en bas de la pile" se rapporte  à  l'objet
	      situé au niveau 1 de la pile.

       Séquence IF/THEN/ELSE/END
	      Exécute les instructions entre IF et THEN.
	      Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir
	      ci-dessus), exécute les instructions entre THEN et ELSE (ou  END
	      s'il n'y a pas de ELSE), sinon exécute les instructions du ELSE.
	      ELSE est facultatif.

       Exemple 1
	      Prends l'élément en bas de la pile et indique s'il est supérieur
	      ou égal à zéro, ou bien négatif
	      << IF 0 >= THEN "Positif ou nul" ELSE "Négatif" END >>

       Exemple 2
	      Exécute toujours les instructions du THEN
	      << IF 1 THEN "Toujours exécuté" ELSE "Jamais exécuté" END >>

       Exemple 3
	      Ne fais rien (!)
	      << IF 0 THEN "Jamais exécuté" END >>

       Séquence WHILE/REPEAT/END
	      Exécute les instructions entre WHILE et REPEAT.
	      Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir
	      ci-dessus), exécute les instructions  du	REPEAT	et  recommence
	      depuis le début du WHILE.

       Exemple
	      Calcule  le  plus  petit	N pour lequel somme(i^2 avec i prenant
	      toutes les valeurs entières dans l'intervalle 1..N) >= 100
	      << 0 0 -> n << WHILE DUP 100 < REPEAT n SQ + n 1 + 'n' STO END n
	      >> >>

       Séquence DO/UNTIL/END
	      Exécute  les  instructions entre DO et UNTIL puis entre UNTIL et
	      END.
	      Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir
	      ci-dessus), recommence depuis le début du DO.

       Exemple
	      Calcule  le  plus  petit	N pour lequel somme(1/i avec i prenant
	      toutes les valeurs entières dans l'intervalle 1..N) >= 3
	      << 0 0 -> n << DO n 1 + 'n' STO n INV + UNTIL DUP 7 >= END n  >>
	      >>

       Séquence FOR|START/NEXT|STEP
	      FOR  ou  START  démarre une boucle en prenant deux arguments, le
	      premier (deuxième niveau de la pile) étant la valeur du compteur
	      au  départ,  le  deuxième  (premier  niveau de la pile) étant la
	      valeur  cible  du  compteur,  au-delà  de  laquelle  la	boucle
	      s'arrête.
	      START  est  une  boucle  anonyme.  FOR prend un nom et l'utilise
	      comme variable locale pour le compteur.
	      NEXT incrémente le compteur d'une unité si la valeur  cible  est
	      supérieure  à  la  valeur  de  départ, le décrémente d'une unité
	      sinon.
	      STEP prend la valeur en bas de la pile et l'ajoute au  compteur.
	      NEXT  peut  être	utilisé indifféremment avec FOR et START, même
	      chose pour STEP.

       Exemple 1
	      Calcule la somme des carrés des entiers de 1 à 10
	      << 0 1 10 FOR i i SQ + NEXT >>

       Exemple 2
	      Calcule somme(2^i avec i prenant	toutes	les  valeurs  entières
	      dans  l'intervalle  1..N),  N  étant  la première valeur dans la
	      pile.
	      << 0 1 1 4 ROLL START DUP ROT + SWAP 2 * NEXT DROP >> EVAL

       Exemple 3
	      Calcule somme(i avec i prenant toutes les valeurs impaires  dans
	      l'intervalle 1..N), N étant la première valeur dans la pile.
	      << 0 1 ROT FOR i i + 2 STEP >>

       Documentation RPL
	      RPL  est	le langage de programmation des calculatrices HP fonc‐
	      tionnant en notation polonaise inverse.
	      http://en.wikipedia.org/wiki/RPL_%28programming_language%29

FICHIERS D'INITIALISATION
       ~/.prpn/stackrc
	      Réglages et contenu de la pile.

       ~/.prpn/varsrc
	      Structure contenant les variables, et répertoire courant.

AUTEUR
       Écrit par Sébastien Millet <sebastien.millet1@club-internet.fr>.
       Autorisation est donnée de copier, distribuer et/ou modifier  ce  docu‐
       ment  selon  les  termes de la licence "GNU General Public License". La
       version 3 est publiée par la Free Software Foundation.

BUGS
       Différence entre prpn et prpnc

       Linux  prpn peut être exécuté avec l'option -c. Dans ce cas le résultat
	      est  presque  équivalent	à prpnc. "Presque" seulement. prpn est
	      compilé avec la librairie WxWidgets et initialise des ressources
	      graphiques  au  démarrage.  Si les ressources graphiques ne sont
	      pas trouvées, le programme ne démarre pas. Par exemple, si  vous
	      exécutez la commande suivante
		   DISPLAY="" prpn -c
	      Vous obtenez ce résultat
		   Error: Unable to initialize gtk, is DISPLAY set properly?
	      prpnc résout ce problème, car il n'est *pas* compilé avec WxWid‐
	      gets et peut fonctionner dans un terminal ne disposant  d'aucune
	      ressource graphique. Un moyen élégant de régler cette difficulté
	      serait  d'empêcher  WxWidgets   d'initialiser   les   ressources
	      graphiques  lorsque l'option -c est présente. Si vous connaissez
	      un moyen robuste de le faire  (portable  quels  que  soient  les
	      systèmes	et  les  versions...),	l'auteur  de  ce programme est
	      intéressé !

       Windows
	      prpn.exe ne peut *pas* être exécuté avec l'option -c. Sous  Win‐
	      dows,  WxWidgets	déconnecte  le	processus  de  son terminal de
	      contrôle. La solution est la même que sous  Linux,  sauf	qu'ici
	      c'est  obligatoire  :  vous  devez  utiliser  prpnc.exe  si vous
	      souhaitez utiliser la version en ligne de commande.



3 octobre 2010			 version 0.5.1			       pRPN(1)
