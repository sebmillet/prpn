.\" Écrit par Sébastien Millet
.\"
.TH pRPN 1 "version 0.5.1" "3 octobre 2010"

.SH NAME
pRPN \- une calculatrice en notation polonaise inverse multi systèmes
d'exploitation

.SH SYNOPSIS
.B prpn [options]
.br
.B prpnc [options]
.TP
prpn est l'exécutable principal, en mode graphique. prpnc est la version en ligne de commande. \fBprpnc\fP est équivalent à \fBprpn -c\fP.
.br

.SH DESCRIPTION
Le programme \fBpRPN\fP est une calculatrice en notation polonaise inverse inspirée des calculatrices HP de la fin des années 80.
.SH OPTIONS
.TP
.B \-h,\ \-\-help
Affiche l'aide et quitte.
.TP
.B \-v\ \-\-version
Affiche le numéro de version et quitte.
.TP
.B \-c,\ \-\-console
Exécution en mode console.
.TP
.B \-w,\ \-\-width\ \fIwidth\fP
Définis la largeur à \fIwidth\fP, mesurée en nombre de caractères. 23 par défaut.
.TP
.B \-h,\ \-\-height\ \fIheight\fP
Définis la hauteur à \fIheight\fP, mesurée en nombre de lignes. 5 par défaut.
.TP
.B \-\-min-stack-height\ \fImin-stack-height\fP
Définis la hauteur minimale à \fIheight\fP, mesurée en nombre de lignes. \fIheight\fP par défaut. Uniquement en mode console.
.TP
.B \-b,\ \-\-batch
Mode batch, implique le mode console.
.TP
.B \-z,\ \-\-dry\-run
Ignore les fichiers rc.
.TP
.B \-a,\ \-\-class
Affiche le comptage des classes avant de terminer.
.TP
.B \-d,\ \-\-debug\ \fIdebug_option\fP
Mode debug, prend un paramètre.
.SH "TYPES D'OBJETS"
.TP
.I Donnée
.TP
.B Nombre réel
1.23456e-25    
.TP
.B Nombre complexe
( )	(123.45, 678.90)
.TP
.B Entier binaire
#	# 123AB
.TP
.B Chaîne de caractères
" "	"RESULT"
.TP
.B Vecteur
[ ]	[1.23 4.56 7.89]
.TP
.B Matrice
[[ ]]	[[1.23 4.56] [6.54 3.21]]
.TP
.B Liste
{ }	{1.23 "ABC" # 45d}
.TP
.I Noms
.TP
.B Nom
\' \'	\'CALC\'
.TP
.I Procédures
.TP
.B Programme
<< >>	<< DUP + SWAP >>
.TP
.B Algébrique
\' \'	\'X+2*Y=Z\'
.SH COMMANDES
Les commandes sont suivies du nombre d'arguments qu'elles prennent, entre parenthèses. Ces arguments sont pris dans la pile.
.TP
.B _HELP\ (0)
Affiche un écran d'aide
.TP
.B _HELP_FLAGS\ (0)
Affiche la liste des indicateurs binaires
.TP
.B _EXIT\ (0)
Quitte le programme
.TP
.B _ABOUT\ (0)
Informations sur ce programme
.TP
.B +\ (2)
Addition : x + y
.TP
.B -\ (2)
Soustraction : x - y
.TP
.B *\ (2)
Multiplication : x * y
.TP
.B /\ (2)
Division : x / y
.TP
.B ^\ (2)
Puissance : x ^ y
.TP
.B %\ (2)
Pourcentage : (x * y) / 100
.TP
.B %CH\ (2)
Pourcentage de changement : 100 * (y - x) / x
.TP
.B %T\ (2)
Pourcentage du total : 100 * y / x
.TP
.B MOD\ (2)
Modulo : x - y * FLOOR(x / y)
.TP
.B MIN\ (2)
Minimum de deux réels
.TP
.B MAX\ (2)
Maximum de deux réels
.TP
.B COS\ (1)
Cosinus
.TP
.B SIN\ (1)
Sinus
.TP
.B TAN\ (1)
Tangente
.TP
.B ACOS\ (1)
Arc-cosinus
.TP
.B ASIN\ (1)
Arc-sinus
.TP
.B ATAN\ (1)
Arc-tangente
.TP
.B LN\ (1)
Logarithme (base e)
.TP
.B EXP\ (1)
Exponentiel
.TP
.B LOG\ (1)
Logarithme (base 10)
.TP
.B ALOG\ (1)
Exponentiel en base 10 (10^x)
.TP
.B LNP1\ (1)
LN(1+x)
.TP
.B EXPM\ (1)
EXP(x)-1
.TP
.B COSH\ (1)
Cosinus hyperbolique
.TP
.B SINH\ (1)
Sinus hyperbolique
.TP
.B TANH\ (1)
Tangente hyperbolique
.TP
.B ACOSH\ (1)
Arc-cosinus hyperbolique
.TP
.B ASINH\ (1)
Arc-sinus hyperbolique
.TP
.B ATANH\ (1)
Arc-tangente hyperbolique
.TP
.B NEG\ (1)
Opposé
.TP
.B IP\ (1)
Partie entière
.TP
.B FP\ (1)
Partie décimale
.TP
.B FLOOR\ (1)
Plus grand entier inférieur ou égal à x
.TP
.B CEIL\ (1)
Plus petit entier supérieur ou égal à x
.TP
.B ABS\ (1)
Valeur absolue de x
.TP
.B SIGN\ (1)
Signe de x : peut être -1, 0 ou 1
.TP
.B MANT\ (1)
Mantisse de x
.TP
.B XPON\ (1)
Exponentielle de x
.TP
.B INV\ (1)
1/x
.TP
.B SQ\ (1)
Carré
.TP
.B SQR\ (1)
Racine carrée
.TP
.B RDZ\ (1)
Initializes random values series, 0 to start from a timer value
.TP
.B RAND\ (0)
Get a random value x, 0 <= x < 1
.TP
.B MINR\ (0)
Plus petit réel supérieur à zéro représentable par la calculatrice
.TP
.B MAXR\ (0)
Plus grand réel représentable par la calculatrice
.TP
.B ->HMS\ (1)
Convertis un décimal en nombre HMS (h.MMSSss)
.TP
.B HMS->\ (1)
Convertis un nombre HMS (h.MMSSss) en décimal
.TP
.B HMS+\ (2)
Additionne deux nombres HMS (h.MMSSss)
.TP
.B HMS-\ (2)
Soustrais deux nombres HMS (h.MMSSss)
.TP
.B D->R\ (1)
Convertis des degrés en radians (*PI/180)
.TP
.B R->D\ (1)
Convertis des radians en degrés (*180/PI)
.TP
.B RAD\ (0)
Utilise le radian pour les mesures angulaires
.TP
.B DEG\ (0)
Utilise le degré pour les mesures angulaires
.TP
.B +ML\ (0)
Affiche le premier élément sur plusieurs lignes
.TP
.B -ML\ (0)
Affiche le premier élément sur une seule ligne
.TP
.B RDXP\ (0)
Utilise la caractère '.' comme séparateur décimal
.TP
.B RDXC\ (0)
Utilise la caractère ',' comme séparateur décimal
.TP
.B R->C\ (2)
Réel à complexe
.TP
.B C->R\ (1)
Complexe à réel
.TP
.B RE\ (1)
Partie réelle d'un nombre complexe ou d'un tableau
.TP
.B IM\ (1)
Partie imaginaire d'un nombre complexe ou d'un tableau
.TP
.B CONJ\ (1)
Conjugué d'un nombre complexe ou d'un tableau
.TP
.B ARG\ (1)
Argument d'un nombre complexe
.TP
.B R->P\ (1)
Conversion des coordonnées d'un nombre complexe de rectangulaire à polaire
.TP
.B P->R\ (1)
Conversion des coordonnées d'un nombre complexe de polaire à rectangulaire
.TP
.B SAME\ (2)
Est identique
.TP
.B ==\ (2)
Est égal à
.TP
.B <>\ (2)
Est différent de
.TP
.B <\ (2)
Est plus petit que
.TP
.B <=\ (2)
Est plus petit que, ou égal à
.TP
.B >\ (2)
Est plus grand que
.TP
.B >=\ (2)
Est plus grand que, ou égal à
.TP
.B AND\ (2)
Et logique
.TP
.B OR\ (2)
Ou logique
.TP
.B XOR\ (2)
Xor logique (exclusion)
.TP
.B NOT\ (1)
Non logique
.TP
.B DUP\ (1)
Copie le premier élément
.TP
.B SWAP\ (2)
Échange les deux premiers éléments
.TP
.B DROP\ (1)
Supprime le premier élément
.TP
.B CLEAR\ (0)
Efface la pile
.TP
.B OVER\ (2)
Copie le second élément
.TP
.B DUP2\ (2)
Copie les deux premiers éléments
.TP
.B DROP2\ (2)
Supprime les deux premiers éléments
.TP
.B ROT\ (3)
Déplace le troisième élément en première position
.TP
.B ROLLD\ (1)
Déplace le premier élément en Nième position
.TP
.B ROLL\ (1)
Déplace le Ne élément en première position
.TP
.B PICK\ (1)
Copie le Ne élément
.TP
.B DUPN\ (1)
Copie les N premiers éléments
.TP
.B DROPN\ (1)
Supprime les N premiers éléments
.TP
.B DEPTH\ (0)
Renvoie le nombre d'éléments dans la pile
.TP
.B SF\ (1)
Active l'indicateur binaire
.TP
.B CF\ (1)
Désactive l'indicateur binaire
.TP
.B FS?\ (1)
Renvoie 1 si l'indicateur binaire est activé, 0 sinon
.TP
.B FC?\ (1)
Renvoie 0 si l'indicateur binaire est activé, 1 sinon
.TP
.B FS?C\ (1)
Exécute FS? et désactive l'indicateur binaire
.TP
.B FC?C\ (1)
Exécute FC? et désactive l'indicateur binaire
.TP
.B ->STR\ (1)
Convertis un élément en chaîne de caractères
.TP
.B STR->\ (0)
Convertis une chaîne de caractère en éléments
.TP
.B SUB\ (3)
Extrais le contenu d'une chaîne de caractères ou d'une liste
.TP
.B ->LIST\ (1)
Mets les éléments dans une liste
.TP
.B LIST->\ (1)
Convertis la liste en ses éléments
.TP
.B GET\ (2)
Extrais un élément d'une liste ou d'un tableau
.TP
.B GETI\ (2)
Extrais un élément d'une liste ou d'un tableau par incréments
.TP
.B PUT\ (3)
Remplace un élément dans une liste ou un tableau
.TP
.B PUTI\ (3)
Remplace un élément dans une liste ou un tableau par incréments
.TP
.B SIZE\ (1)
Dimension d'une liste ou d'un tableau
.TP
.B ARRY->\ (1)
Remplace un tableau par ses éléments
.TP
.B ->ARRY\ (1)
Crée un tableau avec les éléments de la pile
.TP
.B CON\ (2)
Crée un tableau constant
.TP
.B TRN\ (1)
Transpose une matrice
.TP
.B RDM\ (2)
Modifie les dimensions d'un tableau
.TP
.B IDN\ (1)
Crée une matrice identité
.TP
.B CROSS\ (2)
Produit vectoriel
.TP
.B DOT\ (2)
Produit scalaire
.TP
.B EVAL\ (0)
Évalue l'élément
.TP
.B STO\ (2)
Enregistre la valeur dans la variable
.TP
.B RCL\ (1)
Récupère la valeur de la variable
.TP
.B PURGE\ (1)
Supprime la variable
.TP
.B VARS\ (0)
Renvoie la liste des variables dans le répertoire courant
.TP
.B PATH\ (0)
Renvoie le répertoire en cours sous forme de liste
.TP
.B CRDIR\ (1)
Crée un répertoire
.TP
.B HOME\ (0)
Définis le répertoire racine comme répertoire courant
.TP
.B UP\ (0)
Définis le répertoire parent comme répertoire courant
.TP
.B BIN\ (0)
Utilise le mode binaire pour les entiers binaires
.TP
.B OCT\ (0)
Utilise le mode octal pour les entiers binaires
.TP
.B DEC\ (0)
Utilise le mode décimal pour les entiers binaires
.TP
.B HEX\ (0)
Utilise le mode hexadécimal pour les entiers binaires
.TP
.B STWS\ (1)
Définis le nombre de bits des entiers binaires (de 1 à 64)
.TP
.B RCWS\ (0)
Renvoie le nombre de bits des entiers binaires
.TP
.B B->R\ (1)
Convertis un entier binaire en réel
.TP
.B R->B\ (1)
Convertis un réel en entier binaire
.TP
.B RCLF\ (0)
Enregistre l'état des indicateurs binaires dans un entier binaire
.TP
.B STOF\ (1)
Récupère l'état des indicateurs binaires depuis un entier binaire
.TP
.B WAIT\ (1)
Pause d'une durée définie en secondes
.TP
.B HALT\ (0)
Suspends l'exécution du programme
.TP
.B SST\ (0)
Exécute une instruction dans le programme
.TP
.B ABORT\ (0)
Arrête l'exécution du programme courant
.TP
.B KILL\ (0)
Arrête l'exécution de tous les programmes
.TP
.B CONT\ (0)
Reprends l'exécution du programme
.TP
.B STD\ (0)
Règle l'affichage des réels à 'standard'
.TP
.B SCI\ (1)
Règle l'affichage des réels à 'scientifique'
.TP
.B FIX\ (1)
Règle l'affichage des réels à 'nombre de décimales fixe'
.TP
.B ENG\ (1)
Règle l'affichage des réels à 'ingénieur'
.TP
.B CLLCD\ (0)
Efface l'écran
.TP
.B CLMF\ (0)
Désarme l'indicateur d'affichage => dégèle l'affichage de la pile
.TP
.B DISP\ (2)
Affiche une chaîne de caractères sur une ligne de l'écran
.TP
.B _READ\ (1)
Lis le fichier et met son contenu dans la pile
.TP
.B _WRITE\ (2)
Écris le second élément de la pile dans le fichier nommé par le premier élément
.TP
.B _HACK-REAL-MGMT\ (1)
Interne : règle la gestion de l'affichage des réels en mode 'standard'
.TP
.B _HACK-REAL-DOT\ (1)
Interne : détermine s'il faut afficher un point à la fin des réels
.TP
.B UNDO\ (0)
Annule la dernière commande, 50 niveaux par défaut
.TP
.B _UNDO_LEVELS\ (1)
Définis le nombre de niveaux d'annulation
.TP
.B _UNDO_LEVELS?\ (0)
Renvoie le nombre de niveaux d'annulations
.SH "RÉSOLUTION DE SYSTÈMES D'ÉQUATIONS LINÉAIRES"
.TP
Vous pouvez résoudre un système d'équations linéaires en divisant un vecteur par une matrice.
.br
.I Exemple
Vous voudriez résoudre le système
.br
  2x - y + z = 13
  x + 5y +3z = 3
  -2x + 4z = 4
.br
Saisissez le vecteur
.br
  [13 3 4]
.br
Ensuite saisissez la matrice
.br
  [[2 -1 1][1 5 3][-2 0 4]]
.br
Faites une division en cliquant sur le bouton '/'. Le résultat est là :
.br
  [4 -2 3]
.br
Ce qui se lit "la solution est x = 4, y = -2 et z = 3"
.SH "INSTRUCTIONS DE CONTRÔLE DES PROGRAMMES"
.TP
.B Note au sujet des booléens
Un test (IF, WHILE ou UNTIL, cf. ci-après) prend une valeur dans la pile.
Cette valeur doit être de type réel. Toute valeur non nulle est traitée comme
VRAI, une valeur nulle comme FAUX.
.br
Ci-dessous, le terme "en bas de la pile" se rapporte à l'objet situé au niveau
1 de la pile.
.TP
.B Séquence IF/THEN/ELSE/END
Exécute les instructions entre IF et THEN.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
exécute les instructions entre THEN et ELSE (ou END s'il n'y a pas de ELSE),
sinon exécute les instructions du ELSE. ELSE est facultatif.
.TP
.I Exemple 1
Prends l'élément en bas de la pile et indique s'il est supérieur ou égal à
zéro, ou bien négatif
.br
<< IF 0 >= THEN "Positif ou nul" ELSE "Négatif" END >>
.TP
.I Exemple 2
Exécute toujours les instructions du THEN
.br
<< IF 1 THEN "Toujours exécuté" ELSE "Jamais exécuté" END >>
.TP
.I Exemple 3
Ne fais rien (!)
.br
<< IF 0 THEN "Jamais exécuté" END >>
.TP
.B Séquence WHILE/REPEAT/END
Exécute les instructions entre WHILE et REPEAT.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
exécute les instructions du REPEAT et recommence depuis le début du WHILE.
.TP
.I Exemple
Calcule le plus petit N pour lequel somme(i^2 avec i prenant toutes les
valeurs entières dans l'intervalle 1..N) >= 100
.br
<< 0 0 -> n << WHILE DUP 100 < REPEAT n SQ + n 1 + 'n' STO END n >> >>
.TP
.B Séquence DO/UNTIL/END
Exécute les instructions entre DO et UNTIL puis entre UNTIL et END.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
recommence depuis le début du DO.
.TP
.I Exemple
Calcule le plus petit N pour lequel somme(1/i avec i prenant toutes les
valeurs entières dans l'intervalle 1..N) >= 3
.br
<< 0 0 -> n << DO n 1 + 'n' STO n INV + UNTIL DUP 7 >= END n >> >>
.TP
.B Séquence FOR|START/NEXT|STEP
FOR ou START démarre une boucle en prenant deux arguments, le premier
(deuxième niveau de la pile) étant la valeur du compteur au départ, le
deuxième (premier niveau de la pile) étant la valeur cible du compteur,
au-delà de laquelle la boucle s'arrête.
.br
START est une boucle anonyme. FOR prend un nom et l'utilise comme variable locale pour le compteur.
.br
NEXT incrémente le compteur d'une unité si la valeur cible est supérieure à la valeur de départ, le décrémente d'une unité sinon.
.br
STEP prend la valeur en bas de la pile et l'ajoute au compteur. NEXT peut être
utilisé indifféremment avec FOR et START, même chose pour STEP.
.TP
.I Exemple 1
Calcule la somme des carrés des entiers de 1 à 10
.br
<< 0 1 10 FOR i i SQ + NEXT >>
.TP
.I Exemple 2
Calcule somme(2^i avec i prenant toutes les valeurs entières dans l'intervalle
1..N), N étant la première valeur dans la pile.
.br
<< 0 1 1 4 ROLL START DUP ROT + SWAP 2 * NEXT DROP >> EVAL
.TP
.I Exemple 3
Calcule somme(i avec i prenant toutes les valeurs impaires dans l'intervalle
1..N), N étant la première valeur dans la pile.
.br
<< 0 1 ROT FOR i i + 2 STEP >>
.TP
.B Documentation RPL
RPL est le langage de programmation des calculatrices HP fonctionnant en
notation polonaise inverse.
.br
http://en.wikipedia.org/wiki/RPL_%28programming_language%29
.SH "TRUCS"
.TP
.B Augmenter la taille de la zone de saisie
.br
Appuyer sur les touches <Ctrl-Entrée>.
.br
.br
.TP
.B Redimensionner la fenêtre à sa taille originale
.br
Double-cliquer sur la partie "statut" de la fenêtre, où les modes angulaire et binaire sont affichés.
.SH "FICHIERS D'INITIALISATION"
.TP
.B ~/.prpn/stackrc
Réglages et contenu de la pile.
.TP
.B ~/.prpn/varsrc
Structure contenant les variables, et répertoire courant.
.SH AUTEUR
Écrit par Sébastien Millet <sebastien.millet1@club-internet.fr>.
.br
Autorisation est donnée de copier, distribuer et/ou modifier ce document selon les termes de la licence "GNU General Public License". La version 3 est publiée par la Free Software Foundation.
.SH BUGS
.B LNP1 et EXPM
.TP
Ces fonctions sont supposées apporter plus de précision au voisinage de x = 0. Rappel :
LNP1(x) = LN(X + 1) et EXPM(x) = EXP(x) - 1
.br
A l'heure actuelle, ces fonctions n'apportent pas plus de précision, elles appellent simplement LN() et EXP().
.br
.br
.TP
.B Différence entre prpn et prpnc
.TP
.I Linux
prpn peut être exécuté avec l'option -c. Dans ce cas le résultat est presque équivalent à prpnc. "Presque" seulement. prpn est compilé avec la librairie WxWidgets et initialise des ressources graphiques au démarrage. Si les ressources graphiques ne sont pas trouvées, le programme ne démarre pas. Par exemple, si vous exécutez la commande suivante
.br
\fB	DISPLAY="" prpn -c\fP
.br
Vous obtenez ce résultat
.br
\fB	Error: Unable to initialize gtk, is DISPLAY set properly?\fP
.br
prpnc résout ce problème, car il n'est *pas* compilé avec WxWidgets et peut fonctionner dans un terminal ne disposant d'aucune ressource graphique. Un moyen élégant de régler cette difficulté serait d'empêcher WxWidgets d'initialiser les ressources graphiques lorsque l'option -c est présente. Si vous connaissez un moyen robuste de le faire (portable quels que soient les systèmes et les versions...), l'auteur de ce programme est intéressé !
.TP
.I Windows
prpn.exe ne peut *pas* être exécuté avec l'option -c. Sous Windows, WxWidgets déconnecte le processus de son terminal de contrôle. La solution est la même que sous Linux, sauf qu'ici c'est obligatoire : vous devez utiliser prpnc.exe si vous souhaitez utiliser la version en ligne de commande.
