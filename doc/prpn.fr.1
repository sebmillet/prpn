.\" Écrit par Sébastien Millet
.\"
.TH pRPN 1 "version 0.6.1" "1er novembre 2020"

.SH NAME
pRPN \- une calculatrice en notation polonaise inverse multi systèmes
d'exploitation

.SH SYNOPSIS
.B prpn [options]
.br
.B prpnc [options]
.TP
prpn est l'exécutable principal, en mode graphique. prpnc est la version en ligne de commande. \fBprpnc\fP est équivalent à \fBprpn -c\fP.
.br

.SH DESCRIPTION
Le programme \fBpRPN\fP est une calculatrice en notation polonaise inverse inspirée des calculatrices HP de la fin des années 80.
.SH OPTIONS
.TP
.B \-h,\ \-\-help
Affiche l'aide et quitte.
.TP
.B \-v\ \-\-version
Affiche le numéro de version et quitte.
.TP
.B \-c,\ \-\-console
Exécution en mode console.
.TP
.B \-w,\ \-\-width\ \fIwidth\fP
Définis la largeur à \fIwidth\fP, mesurée en nombre de caractères. 23 par défaut.
.TP
.B \-h,\ \-\-height\ \fIheight\fP
Définis la hauteur à \fIheight\fP, mesurée en nombre de lignes. 5 par défaut.
.TP
.B \-\-min-stack-height\ \fImin-stack-height\fP
Définis la hauteur minimale à \fIheight\fP, mesurée en nombre de lignes. \fIheight\fP par défaut. Uniquement en mode console.
.TP
.B \-b,\ \-\-batch
Mode batch, implique le mode console.
.TP
.B \-z,\ \-\-dry\-run
Ignore les fichiers rc.
.TP
.B \-a,\ \-\-class
Affiche le comptage des classes avant de terminer.
.TP
.B \-d,\ \-\-debug\ \fIdebug_option\fP
Mode debug, prend un paramètre.
.SH "TYPES D'OBJETS"
.TP
.I Donnée
.TP
.B Nombre réel
1.23456e-25    
.TP
.B Nombre complexe
( )	(123.45, 678.90)
.TP
.B Entier binaire
#	# 123AB
.TP
.B Chaîne de caractères
" "	"RESULT"
.TP
.B Vecteur
[ ]	[1.23 4.56 7.89]
.TP
.B Matrice
[[ ]]	[[1.23 4.56] [6.54 3.21]]
.TP
.B Liste
{ }	{1.23 "ABC" # 45d}
.TP
.I Noms
.TP
.B Nom
\' \'	\'CALC\'
.TP
.I Procédures
.TP
.B Programme
<< >>	<< DUP + SWAP >>
.TP
.B Algébrique
\' \'	\'X+2*Y=Z\'
.SH COMMANDES
Les commandes sont suivies du nombre d'arguments qu'elles prennent, entre parenthèses. Ces arguments sont pris dans la pile.
.TP
.B _HELP\ (0)
Display a help screen
.TP
.B _HELP_FLAGS\ (0)
Display the list of flags
.TP
.B _EXIT\ (0)
Quit program
.TP
.B _ABOUT\ (0)
Display information about this program
.TP
.B +\ (2)
Addition: x + y
.TP
.B -\ (2)
Subtraction: x - y
.TP
.B *\ (2)
Multiplication: x * y
.TP
.B /\ (2)
Division: x / y
.TP
.B ^\ (2)
Power: x ^ y
.TP
.B %\ (2)
Percentage: (x * y) / 100
.TP
.B %CH\ (2)
Percentage change: 100 * (y - x) / x
.TP
.B %T\ (2)
Percentage of total: 100 * y / x
.TP
.B MOD\ (2)
Modulus: x - y * FLOOR(x / y)
.TP
.B MIN\ (2)
Minimum of two reals
.TP
.B MAX\ (2)
Maximum of two reals
.TP
.B COS\ (1)
Cosine
.TP
.B SIN\ (1)
Sine
.TP
.B TAN\ (1)
Tangent
.TP
.B ACOS\ (1)
Arccos
.TP
.B ASIN\ (1)
Arcsin
.TP
.B ATAN\ (1)
Arctan
.TP
.B LN\ (1)
Logarihtm (e base)
.TP
.B EXP\ (1)
Exponential
.TP
.B LOG\ (1)
Logarithm (10 base)
.TP
.B ALOG\ (1)
10 base exponential (10^x)
.TP
.B LNP1\ (1)
LN(1+x)
.TP
.B EXPM\ (1)
EXP(x)-1
.TP
.B COSH\ (1)
Hyperbolic cosine
.TP
.B SINH\ (1)
Hyperbolic sine
.TP
.B TANH\ (1)
Hyperbolic tangent
.TP
.B ACOSH\ (1)
Arc-hyperbolic cosine
.TP
.B ASINH\ (1)
Arc-hyperbolic sine
.TP
.B ATANH\ (1)
Arc-hyperbolic tangent
.TP
.B NEG\ (1)
Opposite
.TP
.B IP\ (1)
Integer part
.TP
.B FP\ (1)
Fractional part
.TP
.B FLOOR\ (1)
Greatest integer lower than or equal to x
.TP
.B CEIL\ (1)
Lowest integer greater than or equal to x
.TP
.B ABS\ (1)
Absolute of x
.TP
.B SIGN\ (1)
Sign of x: can be -1, 0 or 1
.TP
.B MANT\ (1)
Mantisse of x
.TP
.B XPON\ (1)
Exponent of x
.TP
.B INV\ (1)
1/x
.TP
.B SQ\ (1)
Square
.TP
.B SQR\ (1)
Square root
.TP
.B RDZ\ (1)
Initializes random values series, 0 to start from a timer value
.TP
.B RAND\ (0)
Get a random value x, 0 <= x < 1
.TP
.B MINR\ (0)
Smallest real greater than zero the calcultor can represent
.TP
.B MAXR\ (0)
Biggest real the calcultor can represent
.TP
.B ->HMS\ (1)
Convert a decimal to HMS (h.MMSSss)
.TP
.B HMS->\ (1)
Convert a HMS (h.MMSSss) to a decimal
.TP
.B HMS+\ (2)
Add two HMS (h.MMSSss)
.TP
.B HMS-\ (2)
Subtract two HMS (h.MMSSss)
.TP
.B D->R\ (1)
Convert from degrees to radians
.TP
.B R->D\ (1)
Convert from radians to degrees
.TP
.B RAD\ (0)
Set angular mode to radians
.TP
.B DEG\ (0)
Set angular mode to degrees
.TP
.B +ML\ (0)
Display first item on multilpe lines
.TP
.B -ML\ (0)
Display first item on a single line
.TP
.B RDXP\ (0)
Set the decimal separator to '.'
.TP
.B RDXC\ (0)
Set the decimal separator to ','
.TP
.B R->C\ (2)
Real to complex
.TP
.B C->R\ (1)
Complex to real
.TP
.B RE\ (1)
Get real part of a complex number or array
.TP
.B IM\ (1)
Get imaginary part of a complex number or array
.TP
.B CONJ\ (1)
Get conjugate of a complex number or array
.TP
.B ARG\ (1)
Get argument of a complex number
.TP
.B R->P\ (1)
Rectangular to polar coordinates
.TP
.B P->R\ (1)
Polar to rectangular coordinates
.TP
.B SAME\ (2)
Is identical
.TP
.B ==\ (2)
Equal to
.TP
.B <>\ (2)
Different from
.TP
.B <\ (2)
Lower than
.TP
.B <=\ (2)
Lower than or equal to
.TP
.B >\ (2)
Greater than
.TP
.B >=\ (2)
Greater than or equal to
.TP
.B AND\ (2)
Logical and
.TP
.B OR\ (2)
Logical or
.TP
.B XOR\ (2)
Logical xor
.TP
.B NOT\ (1)
Logical not
.TP
.B DUP\ (1)
Copy the first item
.TP
.B SWAP\ (2)
Exchange the first two items
.TP
.B DROP\ (1)
Delete the first item
.TP
.B CLEAR\ (0)
Clear the stack
.TP
.B OVER\ (2)
Copy the second item
.TP
.B DUP2\ (2)
Copy the first two items
.TP
.B DROP2\ (2)
Delete the first two items
.TP
.B ROT\ (3)
Move the third item to the first position
.TP
.B ROLLD\ (1)
Move the first item to the Nth position
.TP
.B ROLL\ (1)
Move the Nth item to the first position
.TP
.B PICK\ (1)
Copy the Nth item
.TP
.B DUPN\ (1)
Copy the n first items
.TP
.B DROPN\ (1)
Delete the n first items
.TP
.B DEPTH\ (0)
Get the number of items
.TP
.B SF\ (1)
Set flag
.TP
.B CF\ (1)
Clear flag
.TP
.B FS?\ (1)
Return 1 if flag is set, 0 otherwise
.TP
.B FC?\ (1)
Return 0 if flag is set, 1 otherwise
.TP
.B FS?C\ (1)
Do FS? then clear flag
.TP
.B FC?C\ (1)
Do FC? then clear flag
.TP
.B ->STR\ (1)
Convert to string
.TP
.B STR->\ (0)
Convert from string
.TP
.B SUB\ (3)
Extract content from a string or a list
.TP
.B ->LIST\ (1)
Items to list
.TP
.B LIST->\ (1)
Extract items from list
.TP
.B GET\ (2)
Get an item from a list or array
.TP
.B GETI\ (2)
Get an item from a list or array by increments
.TP
.B PUT\ (3)
Put an item into a list or array
.TP
.B PUTI\ (3)
Put an item into a list or array by increments
.TP
.B SIZE\ (1)
Dimension of a list or array
.TP
.B ARRY->\ (1)
Replace an array by all its elements
.TP
.B ->ARRY\ (1)
Create an array from a list of elements
.TP
.B CON\ (2)
Create a constant array
.TP
.B TRN\ (1)
Transpose a matrix-type array
.TP
.B RDM\ (2)
Modify the dimension of an array
.TP
.B IDN\ (1)
Create an identity matrix
.TP
.B CROSS\ (2)
Cross product (vectorial product)
.TP
.B DOT\ (2)
Dot product (scalar product)
.TP
.B EVAL\ (0)
Evaluate item
.TP
.B STO\ (2)
Store value in variable name
.TP
.B RCL\ (1)
Recall value from variable name
.TP
.B PURGE\ (1)
Remove a variable
.TP
.B VARS\ (0)
Get the list of variables in current directory
.TP
.B PATH\ (0)
Get the list from root to current directory
.TP
.B CRDIR\ (1)
Create a directory
.TP
.B HOME\ (0)
Set root directory as the current one
.TP
.B UP\ (0)
Make the parent directory the current one
.TP
.B BIN\ (0)
Use binary mode for binary integers
.TP
.B OCT\ (0)
Use octal mode for binary integers
.TP
.B DEC\ (0)
Use decimal mode for binary integers
.TP
.B HEX\ (0)
Use hexadecimal mode for binary integers
.TP
.B STWS\ (1)
Define the number of bits in binary integers (1 to 64)
.TP
.B RCWS\ (0)
Get the number of bits in binary integers
.TP
.B B->R\ (1)
Convert a binary integer into a real
.TP
.B R->B\ (1)
Convert a real into a binary integer
.TP
.B RCLF\ (0)
Save flag states in a binary integer
.TP
.B STOF\ (1)
Read flag states from a binary integer
.TP
.B WAIT\ (1)
Wait a number of seconds
.TP
.B HALT\ (0)
Halt program execution
.TP
.B SST\ (0)
Execute one step in the program
.TP
.B ABORT\ (0)
Abort current program execution
.TP
.B KILL\ (0)
Abort all programs execution
.TP
.B CONT\ (0)
Resume program execution
.TP
.B STD\ (0)
Set reals display to 'standard'
.TP
.B SCI\ (1)
Set reals display to 'scientific'
.TP
.B FIX\ (1)
Set reals display to 'fixed number of decimals'
.TP
.B ENG\ (1)
Set reals display to 'engineering'
.TP
.B CLLCD\ (0)
Clear the screen
.TP
.B CLMF\ (0)
Clear the message flag => unfreeze stack display
.TP
.B DISP\ (2)
Display an item on a line of the screen
.TP
.B _READ\ (1)
Read file and puts its content in the stack
.TP
.B _WRITE\ (2)
Write the second item into the file named by the first item
.TP
.B _HACK-REAL-MGMT\ (1)
Internal: tune real 'standard' display management
.TP
.B _HACK-REAL-DOT\ (1)
Internal: set whether or not to keep a trailing dot in reals display
.TP
.B UNDO\ (0)
Undo last command, 50 levels by default
.TP
.B _UNDO_LEVELS\ (1)
Define number of undo levels
.TP
.B _UNDO_LEVELS?\ (0)
Get number of undo levels
.TP
.B _UISET\ (1)
Define the type of user interface
.SH "RÉSOLUTION DE SYSTÈMES D'ÉQUATIONS LINÉAIRES"
.TP
Vous pouvez résoudre un système d'équations linéaires en divisant un vecteur par une matrice.
.br
.I Exemple
Vous voudriez résoudre le système
.br
  2x - y + z = 13
  x + 5y +3z = 3
  -2x + 4z = 4
.br
Saisissez le vecteur
.br
  [13 3 4]
.br
Ensuite saisissez la matrice
.br
  [[2 -1 1][1 5 3][-2 0 4]]
.br
Faites une division en cliquant sur le bouton '/'. Le résultat est là :
.br
  [4 -2 3]
.br
Ce qui se lit "la solution est x = 4, y = -2 et z = 3"
.SH "INSTRUCTIONS DE CONTRÔLE DES PROGRAMMES"
.TP
.B Note au sujet des booléens
Un test (IF, WHILE ou UNTIL, cf. ci-après) prend une valeur dans la pile.
Cette valeur doit être de type réel. Toute valeur non nulle est traitée comme
VRAI, une valeur nulle comme FAUX.
.br
Ci-dessous, le terme "en bas de la pile" se rapporte à l'objet situé au niveau
1 de la pile.
.TP
.B Séquence IF/THEN/ELSE/END
Exécute les instructions entre IF et THEN.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
exécute les instructions entre THEN et ELSE (ou END s'il n'y a pas de ELSE),
sinon exécute les instructions du ELSE. ELSE est facultatif.
.TP
.I Exemple 1
Prends l'élément en bas de la pile et indique s'il est supérieur ou égal à
zéro, ou bien négatif
.br
<< IF 0 >= THEN "Positif ou nul" ELSE "Négatif" END >>
.TP
.I Exemple 2
Exécute toujours les instructions du THEN
.br
<< IF 1 THEN "Toujours exécuté" ELSE "Jamais exécuté" END >>
.TP
.I Exemple 3
Ne fais rien (!)
.br
<< IF 0 THEN "Jamais exécuté" END >>
.TP
.B Séquence WHILE/REPEAT/END
Exécute les instructions entre WHILE et REPEAT.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
exécute les instructions du REPEAT et recommence depuis le début du WHILE.
.TP
.I Exemple
Calcule le plus petit N pour lequel somme(i^2 avec i prenant toutes les
valeurs entières dans l'intervalle 1..N) >= 100
.br
<< 0 0 -> n << WHILE DUP 100 < REPEAT n SQ + n 1 + 'n' STO END n >> >>
.TP
.B Séquence DO/UNTIL/END
Exécute les instructions entre DO et UNTIL puis entre UNTIL et END.
.br
Ensuite, prends l'élément en bas de la pile, s'il est vrai (voir ci-dessus),
recommence depuis le début du DO.
.TP
.I Exemple
Calcule le plus petit N pour lequel somme(1/i avec i prenant toutes les
valeurs entières dans l'intervalle 1..N) >= 3
.br
<< 0 0 -> n << DO n 1 + 'n' STO n INV + UNTIL DUP 7 >= END n >> >>
.TP
.B Séquence FOR|START/NEXT|STEP
FOR ou START démarre une boucle en prenant deux arguments, le premier
(deuxième niveau de la pile) étant la valeur du compteur au départ, le
deuxième (premier niveau de la pile) étant la valeur cible du compteur,
au-delà de laquelle la boucle s'arrête.
.br
START est une boucle anonyme. FOR prend un nom et l'utilise comme variable locale pour le compteur.
.br
NEXT incrémente le compteur d'une unité si la valeur cible est supérieure à la valeur de départ, le décrémente d'une unité sinon.
.br
STEP prend la valeur en bas de la pile et l'ajoute au compteur. NEXT peut être
utilisé indifféremment avec FOR et START, même chose pour STEP.
.TP
.I Exemple 1
Calcule la somme des carrés des entiers de 1 à 10
.br
<< 0 1 10 FOR i i SQ + NEXT >>
.TP
.I Exemple 2
Calcule somme(2^i avec i prenant toutes les valeurs entières dans l'intervalle
1..N), N étant la première valeur dans la pile.
.br
<< 0 1 1 4 ROLL START DUP ROT + SWAP 2 * NEXT DROP >> EVAL
.TP
.I Exemple 3
Calcule somme(i avec i prenant toutes les valeurs impaires dans l'intervalle
1..N), N étant la première valeur dans la pile.
.br
<< 0 1 ROT FOR i i + 2 STEP >>
.TP
.B Documentation RPL
RPL est le langage de programmation des calculatrices HP fonctionnant en
notation polonaise inverse.
.br
http://en.wikipedia.org/wiki/RPL_%28programming_language%29
.SH "TRUCS"
.TP
.B Augmenter la taille de la zone de saisie
.br
Appuyer sur les touches <Ctrl-Entrée>.
.br
.br
.TP
.B Redimensionner la fenêtre à sa taille originale
.br
Double-cliquer sur la partie "statut" de la fenêtre, où les modes angulaire et binaire sont affichés.
.SH "FICHIERS D'INITIALISATION"
.TP
.B ~/.prpn/stackrc
Réglages et contenu de la pile.
.TP
.B ~/.prpn/varsrc
Structure contenant les variables, et répertoire courant.
.SH AUTEUR
Écrit par Sébastien Millet <sebastien.millet1@club-internet.fr>.
.br
Autorisation est donnée de copier, distribuer et/ou modifier ce document selon les termes de la licence "GNU General Public License". La version 3 est publiée par la Free Software Foundation.
.SH BUGS
.B LNP1 et EXPM
.TP
Ces fonctions sont supposées apporter plus de précision au voisinage de x = 0. Rappel :
LNP1(x) = LN(X + 1) et EXPM(x) = EXP(x) - 1
.br
A l'heure actuelle, ces fonctions n'apportent pas plus de précision, elles appellent simplement LN() et EXP().
.br
.br
.TP
.B Différence entre prpn et prpnc
.TP
.I Linux
prpn peut être exécuté avec l'option -c. Dans ce cas le résultat est presque équivalent à prpnc. "Presque" seulement. prpn est compilé avec la librairie WxWidgets et initialise des ressources graphiques au démarrage. Si les ressources graphiques ne sont pas trouvées, le programme ne démarre pas. Par exemple, si vous exécutez la commande suivante
.br
\fB	DISPLAY="" prpn -c\fP
.br
Vous obtenez ce résultat
.br
\fB	Error: Unable to initialize gtk, is DISPLAY set properly?\fP
.br
prpnc résout ce problème, car il n'est *pas* compilé avec WxWidgets et peut fonctionner dans un terminal ne disposant d'aucune ressource graphique. Un moyen élégant de régler cette difficulté serait d'empêcher WxWidgets d'initialiser les ressources graphiques lorsque l'option -c est présente. Si vous connaissez un moyen robuste de le faire (portable quels que soient les systèmes et les versions...), l'auteur de ce programme est intéressé !
.TP
.I Windows
prpn.exe ne peut *pas* être exécuté avec l'option -c. Sous Windows, WxWidgets déconnecte le processus de son terminal de contrôle. La solution est la même que sous Linux, sauf qu'ici c'est obligatoire : vous devez utiliser prpnc.exe si vous souhaitez utiliser la version en ligne de commande.
